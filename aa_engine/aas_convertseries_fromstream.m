% This function is automagically generated by aa_build_standalone_1_pragmas
% Automatic Analysis DICOM to NIFTI convertor
% Uses SPM to convert from DICOM to NIFTI-1
%  i=subject number
%  seriesnum=series number
%  outputpath=place to write NIFTI
% Rhodri Cusack MRC CBU, Cambridge 2005

% One of:
%  aas_convertseries_fromstream(aap,inputstream,[,outputpathsuffix])
%  aas_convertseries_fromstream(aap,i,inputstream,[,outputpathsuffix])
%  aas_convertseries_fromstream(aap,i,j,inputstream,[,outputpathsuffix])
%  streamname=inputstreamname
%  i=subject number; j=session number
%  seriesnum=series number
%  outputpath=place to write NIFTI
% Rhodri Cusack MRC CBU, Cambridge 2005
%
function [aap, out_allechoes, dicomheader, subdirs, dicomdata]=aas_convertseries_fromstream(aap,varargin)
%#function spm_dicom_convert
v=varargin;
% if (length(v)>3 && ischar(v{end-2}))
%     outputpathsuffix=v{end};
%     v(end)=[];
% else
%     outputpathsuffix='';
% end

inputstream=v{end};
v(end)=[];

% switch(length(v))
%     case 0
%         outputpath=aas_getstudypath(aap);
%     case 1
%         i=varargin{1};
%         outputpath=aas_getsubjpath(aap,i);
%     case 2
%         i=varargin{1};
%         j=varargin{2};
%         outputpath=aas_getsesspath(aap,i,j);
%     otherwise
%         aas_log(aap,true,'internal error - wrong number of arguments to aas_convertseries_fromstream.');
% end

currdir=pwd;

dicomdata=aas_getfiles_bystream(aap,v{:},inputstream);

% Make a list of all the subdirectories within this dicomdata path (written
% for multi-echoes, but probably useful otherwise) as these need to be done
% in separate chunks
subdir_index=[];
subdirs={};
for fileind=1:size(dicomdata,1)
    pth=fileparts(dicomdata(fileind,:));
    s=find(strcmp(pth,subdirs));
    if (isempty(s))
        subdirs=[subdirs pth];
        s=length(subdirs);
    else
        s=s(1);
    end
    subdir_index(fileind)=s;
end

if isempty(dicomdata)
    aas_log(aap,1,sprintf('ERROR: Did not find a dicom series called %s',inputstream));
end

out_allechoes=[];
for subdirind=1:length(subdirs)
    dicomheader{subdirind}=[];
    out=[];
    outputpath_withsuffix=fullfile(subdirs{subdirind}); %,outputpathsuffix
    aap=aas_makedir(aap,outputpath_withsuffix);
    cd(outputpath_withsuffix);
    dicomdata_subdir=dicomdata(subdir_index==subdirind,:);
    % Limit number of volumes read in at a time
    memLimit = meminfo; memLimit = memLimit.ResFree;
    k=1;
    
    % This array is used to collect sliceing timing info so we can
    % reconstruct the slice order
    sliceInfoD = zeros(0, 3);
    
    while (k<=size(dicomdata_subdir,1))
        oldAcquisitionNumber=-1;
        thispass_numvolumes=0;
        DICOMHEADERS=[];
        while (k<=size(dicomdata_subdir,1))
            
            tmp = spm_dicom_headers(deblank(dicomdata_subdir(k,:)));
            infoD = tmp{1};
            headerFields = fieldnames(infoD);
                
            if k == 1
                chunksize_volumes=memLimit*1024/(infoD.StartOfPixelData+infoD.SizeOfPixelData)/4;
            end
    
            TR = [];
            TE = [];
            sliceorder = '';
            slicetimes = [];
            echospacing = [];
            
            % Private field containing info about TR and slices
            fi = 'Private_0029_1020';
            if isfield(infoD, fi)
                str =  infoD.(fi);
                xstr = char(str');
                
                % Try to extract TR from this private field
                n = findstr(xstr, 'sWiPMemBlock.adFree[8]');
                if ~isempty(n)
                    [junk, r] = strtok(xstr(n:n+100), '=');
                    TR = str2double(strtok(strtok(r, '=')));
                    gotTR = true;
                end
                
                % Try to extract slice order
                n = findstr(xstr, 'sSliceArray.ucMode');
                if ~isempty(n)
                    [t, r] = strtok(xstr(n:n+100), '=');
                    ucmode = strtok(strtok(r, '='));
                    switch(ucmode)
                        case '0x1'
                            sliceorder = 'Ascending';
                        case '0x2'
                            sliceorder = 'Descending';
                        case '0x4'
                            sliceorder = 'Interleaved';
                        otherwise
                            sliceorder = 'Unknown';
                    end
                end
            end
            
            % if we didn't find that private field, use standard fields.
            if isempty(TR) && isfield(infoD, 'RepetitionTime')
                TR = infoD.RepetitionTime;
            else
                aas_log(aap,false,'WARNING: TR not found');
            end
            if isempty(TE) && isfield(infoD, 'EchoTime')
                TE = infoD.EchoTime;
            else
                aas_log(aap,false,'WARNING: TE not found');
            end
            
            % Siemens
            if isempty(sliceorder) && isfield(infoD, 'CSAImageHeaderInfo') && cell_index({infoD.CSAImageHeaderInfo.name},'MosaicRefAcqTimes')
                slicetimes = aas_get_numaris4_numval(infoD.CSAImageHeaderInfo,'MosaicRefAcqTimes')';
                [junk, sliceorder] = sort(slicetimes);
            end
            if isempty(echospacing) && isfield(infoD, 'CSAImageHeaderInfo') && cell_index({infoD.CSAImageHeaderInfo.name},'BandwidthPerPixelPhaseEncode')
                pBWpe = aas_get_numaris4_numval(infoD.CSAImageHeaderInfo,'BandwidthPerPixelPhaseEncode');
                echospacing = 1/(pBWpe * infoD.(headerFields{strcmpi(headerFields,'NumberOfPhaseEncodingSteps')})); % in s
            end
            
            % GE
            if isempty(echospacing) && isfield(infoD,'Private_0043_102c'), echospacing = infoD.Private_0043_102c/10e6; end
            if isfield(infoD,'Private_0025_101b') && numel(infoD.Private_0025_101b) > 14 && all(infoD.Private_0025_101b(5:6) == [31 139]) % GZipped information
                gzip = java.util.zip.GZIPInputStream(java.io.ByteArrayInputStream(uint8(infoD.Private_0025_101b(5:end))));
                buffer = java.io.ByteArrayOutputStream();
                org.apache.commons.io.IOUtils.copy(gzip, buffer);
                gzip.close();
                output = char(typecast(buffer.toByteArray(), 'uint8')');
                if isempty(strfind(output,'xml version'))
                    output = textscan(output,'%s','delimiter','\n'); output = output{1};
                    [subfields, vals] = cellfun(@(x) strtok(x), output,'UniformOutput', false);
                    infoD.Private_0025_101b = [];
                    for f = 1:numel(subfields), infoD.Private_0025_101b.(subfields{f}) = vals{f}(3:end-1); end
                    if isfield(infoD.Private_0025_101b,'PHASEACCEL'), echospacing = echospacing/str2double(infoD.Private_0025_101b.PHASEACCEL); end
                end
            end
            if ~any(strcmpi(headerFields,'NumberOfPhaseEncodingSteps')), infoD.NumberOfPhaseEncodingSteps = infoD.AcquisitionMatrix(1); end
            collectSOinfo = isempty(sliceorder) && isfield(infoD, 'TemporalPositionIdentifier');
            
            % Philips (based on Hester Breman's code for BrainVoyager) 
            if isempty(echospacing) && all(isfield(infoD,{'EPIFactor' 'WaterFatShift' 'MagneticFieldStrength'}))
                epifactor 				 = infoD.EPIFactor;
                water_fat_shift_pixel 	 = infoD.WaterFatShift;
                fieldstrength_tesla 	 = infoD.MagneticFieldStrength;
                
                water_fat_diff_ppm       = 3.35;
                resonance_freq_mhz_tesla = 42.576;
                echo_train_length        = epifactor + 1;
                water_fat_shift_hz       = fieldstrength_tesla * water_fat_diff_ppm * resonance_freq_mhz_tesla; % water_fat_shift_hz 3T = 434.215 Hz
                BW_hz_pixel              = water_fat_shift_hz / water_fat_shift_pixel;
                totBW                    = BW_hz_pixel * echo_train_length;
                echospacing              = 1/totBW;
            end
            
            % [AVG] Add the TR to each DICOMHEADERS instance explicitly before saving (and in seconds!)
            infoD.volumeTR = TR/1000;
            infoD.volumeTE = TE/1000;
            infoD.sliceorder = sliceorder;
            infoD.slicetimes = slicetimes/1000;
            infoD.echospacing = echospacing;
            
            % Single slice per DICOM: 
            % TemporalPositionIdentifier is basically the volume number
            % InstanceNumber is the temporal position in that acqusition
            % SliceLocation is spatial
            sliceInfoD(end+1, 2:3) = [infoD.InstanceNumber infoD.SliceLocation];
            if collectSOinfo
                sliceInfoD(end, 1) = infoD.TemporalPositionIdentifier;
            end
            
            DICOMHEADERS=[DICOMHEADERS {infoD}];
            
            if (DICOMHEADERS{end}.AcquisitionNumber~=oldAcquisitionNumber)
                thispass_numvolumes=thispass_numvolumes+1;
                if (thispass_numvolumes>chunksize_volumes)
                    DICOMHEADERS=DICOMHEADERS(1:(end-1));
                    break
                end
            end
            oldAcquisitionNumber=DICOMHEADERS{end}.AcquisitionNumber;
            k=k+1;
        end
        
        % GE, Philips
        if collectSOinfo
            sliceInfo = sliceInfoD;
            sliceInfo(sliceInfo(:,1)~=1, :) = [];       % Trim volumes that aren't the 1st one
            sliceInfo = sortrows(sliceInfo, [1 3 2]);   % Sort by spatial location (inferior->posterior)
            
            numSlices = size(sliceInfo, 1);
            
            if sum(sliceInfo(:,2) == [1:numSlices]') == numSlices
                sliceorder = 'Ascending';
            elseif sum(sliceInfo(:,2) == [numSlices:-1:1]') == numSlices
                sliceorder = 'Descending';
            elseif	mod(numSlices, 2) && (sum(sliceInfo(:,2) == [1:2:numSlices 2:2:numSlices]') == numSlices)
                sliceorder = 'Interleaved';
            elseif mod(numSlices, 2) && (sum(sliceInfo(:,2) == [2:2:numSlices 1:2:numSlices]') == numSlices)
                sliceorder = 'Interleaved';
            else
                sliceorder = 'Unknown';
            end
            
            aas_log(aap,false,sprintf('Sliceorder %s have been detected', sliceorder));
             
            % Update the DICOMHEADERS
            [junk, sliceorder] = sort(sliceInfo(:,2)); % for Philips 
            DICOMHEADERS = arrayfun(@(x) {setfield(x{1}, 'sliceorder', sliceorder')}, DICOMHEADERS);
            DICOMHEADERS = arrayfun(@(x) {setfield(x{1}, 'slicetimes', x{1}.volumeTR/numSlices*(x{1}.sliceorder-1))}, DICOMHEADERS);
        end
        
        if (~exist('echonumbers','var'))
            DICOMHEADERS_selected=DICOMHEADERS;
        else
            DICOMHEADERS_selected=[];
            for l=1:length(DICOMHEADERS);
                if(any(DICOMHEADERS{l}.EchoNumbers==echonumbers))
                    DICOMHEADERS_selected=[DICOMHEADERS_selected DICOMHEADERS(l)];
                end
            end
        end
        % [AVG] to cope with modern cutting edge scanners, and other probs
        % (e.g. 7T Siemens scanners, which seem to mess up the ICE dimensions...)
        if isfield(aap.directory_conventions, 'dicom_converter') && ~isempty(aap.directory_conventions.dicom_converter)
            aas_log(aap, false, sprintf('INFO: Using alternative %s script...', aap.directory_conventions.dicom_converter))
            SCRIPT = textscan(aap.directory_conventions.dicom_converter,'%s','delimiter',':'); SCRIPT = SCRIPT{1};
            custompath = spm_file(SCRIPT{1},'path');
            addpath(custompath);
            dicom_converter = spm_file(SCRIPT{1},'basename');
            opts = SCRIPT(2:end);
            if cell_index(opts,'aap'), opts{cell_index(opts,'aap')} = aap; end
        else
            custompath = '';
            aas_log(aap, false, 'INFO: Using default spm_dicom_convert...')
            dicom_converter = 'spm_dicom_convert';
            opts = {'all','flat','nii'};
        end
        conv = feval(dicom_converter,DICOMHEADERS_selected,opts{:});
        if ~isempty(custompath), rmpath(custompath); end
        out=[out(:);conv.files(:)];
        
        % one DICOM per slice --> one header per volume
        firstsliceInd = sliceInfoD(:,3) == sliceInfoD(find(sliceInfoD(:,2)==min(sliceInfoD(:,2)),1,'first'),3); % select the ones for the first slices per volume
        DICOMHEADERS = DICOMHEADERS(firstsliceInd); 
        [junk, sortind] = sort(sliceInfoD(firstsliceInd,2));
        DICOMHEADERS = DICOMHEADERS(sortind);

        dicomheader{subdirind}=[dicomheader{subdirind} DICOMHEADERS];
    end
    out_allechoes{subdirind}=unique(out);
    
%     if ~isempty(strfind(inputstream, 'dicom_structural'))
%         % [AVG] This is to cope with a number of strucutral images, so we
%         % may have the DICOM header of each of them...
%         InstanceNumbers = [];
%         DCMnumbers = [];
%         % Loop throught the dicoms to see if the SeriesNumber changes
%         for l=1:length(DICOMHEADERS);
%             InstanceNumber = 100*DICOMHEADERS{l}.SeriesNumber + DICOMHEADERS{l}.EchoNumbers;
%             if all(InstanceNumbers ~= InstanceNumber)
%                 InstanceNumbers(end+1) = InstanceNumber;
%                 DCMnumbers = [DCMnumbers l];
%             end
%         end
%         [junk, so] = sort(InstanceNumbers);
%         dicomheader={DICOMHEADERS{DCMnumbers(so)}};
%     end
end

if numel(dicomheader) == 1
    dicomheader=dicomheader{1};
end

% Single echo, no echo dimension to cell array
if (length(out_allechoes)==1)
    out_allechoes=out_allechoes{1};
end

cd (currdir);
